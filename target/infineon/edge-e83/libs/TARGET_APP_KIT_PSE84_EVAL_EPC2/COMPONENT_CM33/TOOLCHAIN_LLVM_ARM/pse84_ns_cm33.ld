/***************************************************************************//**
* \file pse84_ns_cm33.ld
* \version 1.0.0
*
* Linker file for the LLVM C compiler.
*
* The main purpose of the linker script is to describe how the sections in the
* input files should be mapped into the output file, and to control the memory
* layout of the output file.
*
*
* \note The linker files included with the PDL template projects must be generic
* and handle all common use cases. Your project may not use every section
* defined in the linker files. In that case you may see warnings during the
* build process. In your project, you can simply comment out or remove the
* relevant code in the linker file.
*
********************************************************************************
* \copyright
* Copyright (c) (2025), Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation.
* SPDX-License-Identifier: Apache-2.0
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/
/* Specify the output format for the linker script */
OUTPUT_FORMAT ("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
/* Search for libraries in the current directory */
SEARCH_DIR(.)
/* Specify the group of libraries to link against */
GROUP(-lc -lc++ -lcrt0 -lsemihost)
GROUP(libc.a libm.a libcrt0.a libsemihost.a)
/* Define the entry point of the program, which is the reset handler */
ENTRY(Reset_Handler)

/* Define the stack size for the application */
/* To set stack size in application add makefile ldflags: -Wl,--defsym=APP_MSP_STACK_SIZE=<CUSTOM_VALUE> */
__stack_size = DEFINED(APP_MSP_STACK_SIZE) ? APP_MSP_STACK_SIZE : 0x00001000;

/* Include the device memory definitions generated by the Device Configurator */
INCLUDE cymem_gnu_CM33_0.ld

/* Linker script to place sections and symbol values. Should be used together
 * with other linker script that defines memory regions FLASH and RAM.
 * It references following symbols, which must be defined in code:
 *   Reset_Handler : Entry of reset handler
 *
 * It defines following symbols, which code can use without definition:
 *   __exidx_start
 *   __exidx_end
 *   __copy_table_start__
 *   __copy_table_end__
 *   __zero_table_start__
 *   __zero_table_end__
 *   __data_start__
 *   __preinit_array_start
 *   __preinit_array_end
 *   __init_array_start
 *   __init_array_end
 *   __fini_array_start
 *   __fini_array_end
 *   __data_end__
 *   __bss_start__
 *   __bss_end__
 *   __end__
 *   end
 *   __heap_end
 *   __stack_limit
 *   __stack
 */

/* Device definitions */
VECTORS_ALIGNMENT = 0x400;

/* Compute the difference between C-AHB address and S-AHB address for
*  section m33s_code. This value is used to correctly copy code in the
*  copy table. This is needed because the code needs to be accessed from
*  the C_AHB address (faster, better performance) but since this is a read-only
*  address to perform the copy we need to specify the S-AHB address which
*  allows for writes as well.
*/
m33_code_sel_Offset = ORIGIN(m33_code) - ORIGIN(m33_code_sel);


/* The size of the MCU boot header area at the start of main code region */
MCUBOOT_HEADER_SIZE = 0x400;

/* Define the sections */

SECTIONS
{
    /* This section reserves a space for MCUBoot header */
    .mcu_boot_header(NOLOAD) : ALIGN(MCUBOOT_HEADER_SIZE)
    {
        . += MCUBOOT_HEADER_SIZE;
    } > m33_nvm_sel

    /* This section is intended to hold the main non-secure (NS) application code for the Cortex-M33 */
    /* Performance-sensitive or critical functions that need to be executed in sram are manually excluded */
    .app_code_main : ALIGN(VECTORS_ALIGNMENT)
    {
        /* Keep the vector table */
        KEEP(*(.vectors))
        /* Keep initializers */
        KEEP(*(.init))
        /* Keep finalizers */
        KEEP(*(.fini))
        KEEP(*(__lcxx_override))
        /* Static constructors */
        *crtbegin.*(.ctors)
        *crtbegin?.*(.ctors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .ctors)
        *(SORT(.ctors.*))
        *(.ctors)
        /* Static destructors and atexit() */
        *crtbegin.*(.dtors)
        *crtbegin?.*(.dtors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .dtors)
        *(SORT(.dtors.*))
        *(.dtors)

        . = ALIGN(4);

        /* Read only code (constants) */
        *(.rodata .rodata.* .constdata .constdata.* .conststring .conststring.*)
        /* Exclude certain files from this section as they will be placed in RAM */
        *(EXCLUDE_FILE(*cy_syslib.* *cy_syslib_ext.* *cy_smif.* *cy_smif_memnum.* *cy_smif_memslot.* *cy_smif_sfdp.* *cy_smif_hb_flash.* *mtb_hal_memoryspi.* *mtb_serial_memory.* *freertos/Source*.* *cy_clib_support*.* *cy_mutex_pool*.* *cy_time.* *cyabs_*.* *cy_worker_thread.* *cmsis*.*) .text*)

    } > m33_nvm_sel

    /* Exception tables for ARM architecture */
    .ARM.extab : ALIGN(4)
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)

    } > m33_nvm_sel

    /* Exception index tables for ARM architecture */
    .ARM.exidx : ALIGN(4)
    {
        __exidx_start = .;

        *(.ARM.exidx* .gnu.linkonce.armexidx.*)

        __exidx_end = .;

    } > m33_nvm_sel

    /* Define copying of data from flash memory to RAM during the startup */
    .copy.table : ALIGN(4)
    {
        __copy_table_start__ = .;

        /* Initialized data in SRAM */
        LONG (LOADADDR(.data))                              /* From load address in ext flash  */
        LONG (ADDR(.data))                                  /* To run address in RAM  */
        LONG (SIZEOF(.data)/4)                              /* Size in words */

        /* Performance-sensitive or critical functions that need to be executed in SRAM */
        LONG(LOADADDR(.app_code_ram))                         /* From load address in ext flash */
        LONG(ADDR(.app_code_ram) + m33_code_sel_Offset)       /* To run address in RAM - using S-AHB for copying */
        LONG(SIZEOF(.app_code_ram)/4)                         /* Size in words */

        __copy_table_end__ = .;

    } > m33_nvm_sel

    /* Define zeroing of the uninitialized data section */
    .zero.table : ALIGN(4)
    {
        __zero_table_start__ = .;

        LONG(__bss_start__)                       /* Start of the zero-initialized data section */
        LONG((__bss_end__ - __bss_start__)/4)     /* Size of the zero-initialized data section in words */

        __zero_table_end__ = .;

    } > m33_nvm_sel

    /* A section for performance-sensitive or critical functions that need to be executed in SRAM */
    .app_code_ram : ALIGN(4)
    {
        KEEP(*(.cy_sram_code))
        KEEP(*(.cy_ramfunc))
        KEEP(*(.text.cy_os_common))
        *cy_syslib_ext.*(.text*)
        *cy_syslib.*(.text*)
        *cy_smif.*(.text*)
        *cy_smif_memnum.*(.text*)
        *cy_smif_memslot.*(.text*)
        *cy_smif_sfdp.*(.text*)
        *cy_smif_hb_flash.*(.text*)
        *mtb_hal_memoryspi.*(.text*)
        *mtb_serial_memory.*(.text*)
        *freertos/Source*.*(.text*)
        *cy_clib_support*.*(.text*)
        *cy_mutex_pool*.*(.text*)
        *cy_time.*(.text*)
        *cyabs_*.*(.text*)
        *cy_worker_thread.*(.text*)
        *cmsis*.*(.text*)

        . = ALIGN(4);
    } > m33_code_sel AT > m33_nvm_sel

    /* A section for the vector table */
    .ram_vectors (NOLOAD) : ALIGN(VECTORS_ALIGNMENT)
    {
        KEEP(*(.ram_vectors))
    } > m33_data

    /* A section for initialized data memory */
    .data : ALIGN(4)
    {
        __data_start__ = .;

        *(.data*)
        KEEP(*(.jcr*))

        . = ALIGN(4);

        /* Array of pointers to preinit functions */
        PROVIDE_HIDDEN (__preinit_array_start = .);

        KEEP(*(.preinit_array))

        PROVIDE_HIDDEN (__preinit_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to init functions */
        PROVIDE_HIDDEN (__init_array_start = .);

        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array))

        PROVIDE_HIDDEN (__init_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to finalizer functions */
        PROVIDE_HIDDEN (__fini_array_start = .);

        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array))

        PROVIDE_HIDDEN (__fini_array_end = .);

        . = ALIGN(4);

        __data_end__ = .;
    } > m33_data AT > m33_nvm_sel

    /* Read-only after relocation: Writable during relocation, read-only afterward. */
    .data.rel.ro : ALIGN(16)
    {
        *(.data.rel.ro .data.rel.ro.*)
        *(.got)
        *(.got.plt)
    } > m33_data AT > m33_nvm_sel

    /* A section for non-initialized data memory */
    .bss(NOLOAD) : ALIGN(4)
    {
        __bss_start__ = .;

        *(.bss*)
        *(COMMON)

        . = ALIGN(4);

        __bss_end__ = .;
    } > m33_data

    /* Provide value for the variable requied by crt0 library */
    PROVIDE(__bss_start = __bss_start__);
    PROVIDE(__bss_end = __bss_end__);
    PROVIDE(__bss_size = __bss_end - __bss_start);
    PROVIDE(__data_start = __data_start__);
    PROVIDE(__data_end = __data_end__);
    PROVIDE(__data_size = __data_end - __data_start );
    PROVIDE(__data_source = LOADADDR(.data));
    PROVIDE(__data_source_end = LOADADDR(.data) + SIZEOF(.data));
    PROVIDE(__data_source_size = SIZEOF(.data));

    /* Thread local storage initialized data. */
    .tdata : ALIGN(__tls_align)
    {
        *(.tdata .tdata.* .gnu.linkonce.td.*)
    } > m33_allocatable_shared AT > m33_nvm_sel :ram_init
    PROVIDE(__tls_base = ADDR(.tdata));
    PROVIDE(__tdata_start = ADDR(.tdata));
    PROVIDE(__tdata_end = ADDR(.tdata) + SIZEOF(.tdata));
    PROVIDE(__tdata_source = LOADADDR(.tdata));
    PROVIDE(__tdata_source_end = LOADADDR(.tdata) + SIZEOF(.tdata));
    PROVIDE(__tdata_size = SIZEOF(.tdata) );

    PROVIDE(__edata = __data_end);
    PROVIDE(_edata = __data_end);
    PROVIDE(edata = __data_end);

    /* Thread local storage for non-initialized data. */
    .tbss (NOLOAD) : {
        *(.tbss .tbss.* .gnu.linkonce.tb.*)
        *(.tcommon)
    } > m33_allocatable_shared :tls :ram
    PROVIDE(__bss_start = ADDR(.tbss));
    PROVIDE(__tbss_start = ADDR(.tbss));
    PROVIDE(__tbss_end = ADDR(.tbss) + SIZEOF(.tbss));
    PROVIDE(__tbss_offset = ADDR(.tbss) - ADDR(.tdata));
    PROVIDE(__tbss_size = SIZEOF(.tbss));
    PROVIDE(__tls_end = __tbss_end);
    PROVIDE(__tls_size = __tls_end - __tls_base );
    PROVIDE(__tls_align = MAX(ALIGNOF(.tdata), ALIGNOF(.tbss)) );
    PROVIDE(__tls_size_align = (__tls_size + __tls_align - 1) & ~(__tls_align - 1));
    PROVIDE(__arm32_tls_tcb_offset = MAX(8, __tls_align) );
    PROVIDE(__arm64_tls_tcb_offset = MAX(16, __tls_align) );

    /* A section for variables that should not be initialized during the device startup */
    .noinit (NOLOAD) :
    {
        KEEP(*(.noinit))
        /* LLVM specific workaround to include input section "__DATA, __noinit" */
        KEEP(*(*__noinit))
    } > m33_data

    /* A section for the heap memory */
    .heap(NOLOAD) : ALIGN(8)
    {
        __HeapBase = .;
        __heap_start = .;
        __end__ = .;
        end = __end__;

        KEEP(*(.heap*))

        . = ORIGIN(m33_data) + LENGTH(m33_data) - __stack_size;
        __heap_end = .;
        __HeapLimit = .;
    } > m33_data

    /* Define stack top, and stack limit */
    __stack = ORIGIN(m33_data) + LENGTH(m33_data);
    __stack_limit = __stack - __stack_size;

    /* Check if data + stack still allows for Heap to be placed */
    ASSERT(
        __HeapLimit > __HeapBase,
        "Error: RAM region overflowed with stack. Ensure that the stack size is within the available RAM."
    )

    /* A section for shared RAM memory where only the Cortex-M33 Non Secure can allocate data but all cores can access */
    .cy_sharedmem(NOLOAD) : ALIGN(4)
    {
        KEEP(*(.cy_sharedmem))
        /* LLVM specific workaround to include input section "__DATA, .cy_sharedmem" */
        KEEP(*(*.cy_sharedmem))

        . = ALIGN(4);
    } > m33_allocatable_shared

    /* A section for shared SOC memory */
    .cy_shared_socmem (NOLOAD) : ALIGN(4)
    {
        KEEP(*(.cy_socmem_data))
        KEEP(*(.cy_shared_socmem))

        . = ALIGN(4);
    } > m33_m55_shared

    /* A section for the GPU buffer */
    .cy_gpu_buf(NOLOAD) :
    {
        KEEP(*(.cy_gpu_buf))
    } > gfx_mem

    /* Reserve a trail space for the signature for the bootloader - do not place any code here */
    .cy_trailer(NOLOAD) :
    {
    } > m33_trailer_sel

    /* Throw away C++ exception handling information */
        /DISCARD/ : {
        *(.note .note.*)
        *(.eh_frame .eh_frame.*)
        *(.ARM.extab* .gnu.linkonce.armextab.*)
        *(.ARM.exidx*)
    }
}
