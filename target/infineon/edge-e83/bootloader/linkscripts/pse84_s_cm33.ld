/***************************************************************************//**
* \file pse84_s_cm33.ld
* \version 1.0.0
*
* Linker file for the GNU C compiler.
*
* The main purpose of the linker script is to describe how the sections in the
* input files should be mapped into the output file, and to control the memory
* layout of the output file.
*
*
* \note The linker files included with the PDL template projects must be generic
* and handle all common use cases. Your project may not use every section
* defined in the linker files. In that case you may see warnings during the
* build process. In your project, you can simply comment out or remove the
* relevant code in the linker file.
*
********************************************************************************
* \copyright
* Copyright (c) (2020-2025), Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation.
* SPDX-License-Identifier: Apache-2.0
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/
/* Specify the output format for the linker script */
OUTPUT_FORMAT ("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
/* Search for libraries in the current directory */
SEARCH_DIR(.)
/* Specify the group of libraries to link against */
GROUP(-lgcc -lc -lnosys)
/* Define the entry point of the program, which is the reset handler */
ENTRY(S_Reset_Handler)


/* Define the stack size for the application */
/* To set stack size in application add makefile ldflags: -Wl,--defsym=APP_MSP_STACK_SIZE=<CUSTOM_VALUE> */
PROVIDE(__StackSize = DEFINED(APP_MSP_STACK_SIZE) ? APP_MSP_STACK_SIZE : 0x800);

/* This file is automatically generated. */

CYMEM_CM33_0_S_m55_data_START = 0x48040000;
CYMEM_CM33_0_S_m55_data_S_START = 0x58040000;
CYMEM_CM33_0_S_m55_data_SIZE = 0x00040000;
CYMEM_CM33_0_S_m55_data_OFFSET = 0x00000000;
CYMEM_CM33_0_S_m55_code_START = 0x48000000;
CYMEM_CM33_0_S_m55_code_S_START = 0x58000000;
CYMEM_CM33_0_S_m55_code_SIZE = 0x00040000;
CYMEM_CM33_0_S_m55_code_OFFSET = 0x00000000;
CYMEM_CM33_0_S_user_programmable_START = 0x22011000;
CYMEM_CM33_0_S_user_programmable_C_START = 0x02011000;
CYMEM_CM33_0_S_user_programmable_C_S_START = 0x12011000;
CYMEM_CM33_0_S_user_programmable_S_START = 0x32011000;
CYMEM_CM33_0_S_user_programmable_SIZE = 0x0004A000;
CYMEM_CM33_0_S_user_programmable_OFFSET = 0x00011000;
CYMEM_CM33_0_S_user_nvm_START = 0x2205B000;
CYMEM_CM33_0_S_user_nvm_C_START = 0x0205B000;
CYMEM_CM33_0_S_user_nvm_C_S_START = 0x1205B000;
CYMEM_CM33_0_S_user_nvm_S_START = 0x3205B000;
CYMEM_CM33_0_S_user_nvm_SIZE = 0x00008000;
CYMEM_CM33_0_S_user_nvm_OFFSET = 0x0005B000;
CYMEM_CM33_0_S_m33s_nvm_START = 0x60100000;
CYMEM_CM33_0_S_m33s_nvm_C_START = 0x08100000;
CYMEM_CM33_0_S_m33s_nvm_C_S_START = 0x18100000;
CYMEM_CM33_0_S_m33s_nvm_S_START = 0x70100000;
CYMEM_CM33_0_S_m33s_nvm_SIZE = 0x00200000;
CYMEM_CM33_0_S_m33s_nvm_OFFSET = 0x00100000;
CYMEM_CM33_0_S_m33s_trailer_START = 0x60300000;
CYMEM_CM33_0_S_m33s_trailer_C_START = 0x08300000;
CYMEM_CM33_0_S_m33s_trailer_C_S_START = 0x18300000;
CYMEM_CM33_0_S_m33s_trailer_S_START = 0x70300000;
CYMEM_CM33_0_S_m33s_trailer_SIZE = 0x00040000;
CYMEM_CM33_0_S_m33s_trailer_OFFSET = 0x00300000;
CYMEM_CM33_0_S_m33_nvm_START = 0x60340000;
CYMEM_CM33_0_S_m33_nvm_C_START = 0x08340000;
CYMEM_CM33_0_S_m33_nvm_C_S_START = 0x18340000;
CYMEM_CM33_0_S_m33_nvm_S_START = 0x70340000;
CYMEM_CM33_0_S_m33_nvm_SIZE = 0x00200000;
CYMEM_CM33_0_S_m33_nvm_OFFSET = 0x00340000;
CYMEM_CM33_0_S_m33_trailer_START = 0x60540000;
CYMEM_CM33_0_S_m33_trailer_C_START = 0x08540000;
CYMEM_CM33_0_S_m33_trailer_C_S_START = 0x18540000;
CYMEM_CM33_0_S_m33_trailer_S_START = 0x70540000;
CYMEM_CM33_0_S_m33_trailer_SIZE = 0x00040000;
CYMEM_CM33_0_S_m33_trailer_OFFSET = 0x00540000;
CYMEM_CM33_0_S_m55_nvm_START = 0x60580000;
CYMEM_CM33_0_S_m55_nvm_C_START = 0x08580000;
CYMEM_CM33_0_S_m55_nvm_C_S_START = 0x18580000;
CYMEM_CM33_0_S_m55_nvm_S_START = 0x70580000;
CYMEM_CM33_0_S_m55_nvm_SIZE = 0x00A00000;
CYMEM_CM33_0_S_m55_nvm_OFFSET = 0x00580000;
CYMEM_CM33_0_S_m55_trailer_START = 0x60F80000;
CYMEM_CM33_0_S_m55_trailer_C_START = 0x08F80000;
CYMEM_CM33_0_S_m55_trailer_C_S_START = 0x18F80000;
CYMEM_CM33_0_S_m55_trailer_S_START = 0x70F80000;
CYMEM_CM33_0_S_m55_trailer_SIZE = 0x00040000;
CYMEM_CM33_0_S_m55_trailer_OFFSET = 0x00F80000;
CYMEM_CM33_0_S_m33_hyerram_START = 0x64000000;
CYMEM_CM33_0_S_m33_hyerram_C_START = 0x0C000000;
CYMEM_CM33_0_S_m33_hyerram_C_S_START = 0x1C000000;
CYMEM_CM33_0_S_m33_hyerram_S_START = 0x74000000;
CYMEM_CM33_0_S_m33_hyerram_SIZE = 0x00200000;
CYMEM_CM33_0_S_m33_hyerram_OFFSET = 0x00000000;
CYMEM_CM33_0_S_m55_hyperram_START = 0x64200000;
CYMEM_CM33_0_S_m55_hyperram_C_START = 0x0C200000;
CYMEM_CM33_0_S_m55_hyperram_C_S_START = 0x1C200000;
CYMEM_CM33_0_S_m55_hyperram_S_START = 0x74200000;
CYMEM_CM33_0_S_m55_hyperram_SIZE = 0x00200000;
CYMEM_CM33_0_S_m55_hyperram_OFFSET = 0x00200000;
CYMEM_CM33_0_S_m33_m55_shared_hyperram_START = 0x64400000;
CYMEM_CM33_0_S_m33_m55_shared_hyperram_C_START = 0x0C400000;
CYMEM_CM33_0_S_m33_m55_shared_hyperram_C_S_START = 0x1C400000;
CYMEM_CM33_0_S_m33_m55_shared_hyperram_S_START = 0x74400000;
CYMEM_CM33_0_S_m33_m55_shared_hyperram_SIZE = 0x00C00000;
CYMEM_CM33_0_S_m33_m55_shared_hyperram_OFFSET = 0x00400000;
CYMEM_CM33_0_S_m55_code_secondary_START = 0x26000000;
CYMEM_CM33_0_S_m55_code_secondary_C_START = 0x06000000;
CYMEM_CM33_0_S_m55_code_secondary_C_S_START = 0x16000000;
CYMEM_CM33_0_S_m55_code_secondary_S_START = 0x36000000;
CYMEM_CM33_0_S_m55_code_secondary_SIZE = 0x00060000;
CYMEM_CM33_0_S_m55_code_secondary_OFFSET = 0x00000000;
CYMEM_CM33_0_S_m55_data_secondary_START = 0x26060000;
CYMEM_CM33_0_S_m55_data_secondary_C_START = 0x06060000;
CYMEM_CM33_0_S_m55_data_secondary_C_S_START = 0x16060000;
CYMEM_CM33_0_S_m55_data_secondary_S_START = 0x36060000;
CYMEM_CM33_0_S_m55_data_secondary_SIZE = 0x00160000;
CYMEM_CM33_0_S_m55_data_secondary_OFFSET = 0x00060000;
CYMEM_CM33_0_S_m33_m55_shared_START = 0x261C0000;
CYMEM_CM33_0_S_m33_m55_shared_C_START = 0x061C0000;
CYMEM_CM33_0_S_m33_m55_shared_C_S_START = 0x161C0000;
CYMEM_CM33_0_S_m33_m55_shared_S_START = 0x361C0000;
CYMEM_CM33_0_S_m33_m55_shared_SIZE = 0x00040000;
CYMEM_CM33_0_S_m33_m55_shared_OFFSET = 0x001C0000;
CYMEM_CM33_0_S_gfx_mem_START = 0x26200000;
CYMEM_CM33_0_S_gfx_mem_C_START = 0x06200000;
CYMEM_CM33_0_S_gfx_mem_C_S_START = 0x16200000;
CYMEM_CM33_0_S_gfx_mem_S_START = 0x36200000;
CYMEM_CM33_0_S_gfx_mem_SIZE = 0x00300000;
CYMEM_CM33_0_S_gfx_mem_OFFSET = 0x00200000;
CYMEM_CM33_0_S_m33s_shared_START = 0x24001000;
CYMEM_CM33_0_S_m33s_shared_C_START = 0x04001000;
CYMEM_CM33_0_S_m33s_shared_C_S_START = 0x14001000;
CYMEM_CM33_0_S_m33s_shared_S_START = 0x34001000;
CYMEM_CM33_0_S_m33s_shared_SIZE = 0x00001000;
CYMEM_CM33_0_S_m33s_shared_OFFSET = 0x00001000;
CYMEM_CM33_0_S_m33s_code_START = 0x24002000;
CYMEM_CM33_0_S_m33s_code_C_START = 0x04002000;
CYMEM_CM33_0_S_m33s_code_C_S_START = 0x14002000;
CYMEM_CM33_0_S_m33s_code_S_START = 0x34002000;
CYMEM_CM33_0_S_m33s_code_SIZE = 0x00035000;
CYMEM_CM33_0_S_m33s_code_OFFSET = 0x00002000;
CYMEM_CM33_0_S_m33s_data_START = 0x24037000;
CYMEM_CM33_0_S_m33s_data_C_START = 0x04037000;
CYMEM_CM33_0_S_m33s_data_C_S_START = 0x14037000;
CYMEM_CM33_0_S_m33s_data_S_START = 0x34037000;
CYMEM_CM33_0_S_m33s_data_SIZE = 0x00021000;
CYMEM_CM33_0_S_m33s_data_OFFSET = 0x00037000;
CYMEM_CM33_0_S_m33_code_START = 0x24058000;
CYMEM_CM33_0_S_m33_code_C_START = 0x04058000;
CYMEM_CM33_0_S_m33_code_C_S_START = 0x14058000;
CYMEM_CM33_0_S_m33_code_S_START = 0x34058000;
CYMEM_CM33_0_S_m33_code_SIZE = 0x00065000;
CYMEM_CM33_0_S_m33_code_OFFSET = 0x00058000;
CYMEM_CM33_0_S_m33_data_START = 0x240BD000;
CYMEM_CM33_0_S_m33_data_C_START = 0x040BD000;
CYMEM_CM33_0_S_m33_data_C_S_START = 0x140BD000;
CYMEM_CM33_0_S_m33_data_S_START = 0x340BD000;
CYMEM_CM33_0_S_m33_data_SIZE = 0x00040000;
CYMEM_CM33_0_S_m33_data_OFFSET = 0x000BD000;
CYMEM_CM33_0_S_m33s_allocatable_shared_START = 0x240FD000;
CYMEM_CM33_0_S_m33s_allocatable_shared_C_START = 0x040FD000;
CYMEM_CM33_0_S_m33s_allocatable_shared_C_S_START = 0x140FD000;
CYMEM_CM33_0_S_m33s_allocatable_shared_S_START = 0x340FD000;
CYMEM_CM33_0_S_m33s_allocatable_shared_SIZE = 0x00001000;
CYMEM_CM33_0_S_m33s_allocatable_shared_OFFSET = 0x000FD000;
CYMEM_CM33_0_S_m33_allocatable_shared_START = 0x240FE000;
CYMEM_CM33_0_S_m33_allocatable_shared_C_START = 0x040FE000;
CYMEM_CM33_0_S_m33_allocatable_shared_C_S_START = 0x140FE000;
CYMEM_CM33_0_S_m33_allocatable_shared_S_START = 0x340FE000;
CYMEM_CM33_0_S_m33_allocatable_shared_SIZE = 0x00001000;
CYMEM_CM33_0_S_m33_allocatable_shared_OFFSET = 0x000FE000;
CYMEM_CM33_0_S_m55_allocatable_shared_START = 0x240FF000;
CYMEM_CM33_0_S_m55_allocatable_shared_C_START = 0x040FF000;
CYMEM_CM33_0_S_m55_allocatable_shared_C_S_START = 0x140FF000;
CYMEM_CM33_0_S_m55_allocatable_shared_S_START = 0x340FF000;
CYMEM_CM33_0_S_m55_allocatable_shared_SIZE = 0x00001000;
CYMEM_CM33_0_S_m55_allocatable_shared_OFFSET = 0x000FF000;

MEMORY
{
    m55_data : ORIGIN = 0x48040000, LENGTH = 0x00040000
    m55_data_S : ORIGIN = 0x58040000, LENGTH = 0x00040000
    m55_code : ORIGIN = 0x48000000, LENGTH = 0x00040000
    m55_code_S : ORIGIN = 0x58000000, LENGTH = 0x00040000
    user_programmable : ORIGIN = 0x22011000, LENGTH = 0x0004A000
    user_programmable_C : ORIGIN = 0x02011000, LENGTH = 0x0004A000
    user_programmable_C_S : ORIGIN = 0x12011000, LENGTH = 0x0004A000
    user_programmable_S : ORIGIN = 0x32011000, LENGTH = 0x0004A000
    user_nvm : ORIGIN = 0x2205B000, LENGTH = 0x00008000
    user_nvm_C : ORIGIN = 0x0205B000, LENGTH = 0x00008000
    user_nvm_C_S : ORIGIN = 0x1205B000, LENGTH = 0x00008000
    user_nvm_S : ORIGIN = 0x3205B000, LENGTH = 0x00008000
    m33s_nvm : ORIGIN = 0x60100000, LENGTH = 0x00200000
    m33s_nvm_C : ORIGIN = 0x08100000, LENGTH = 0x00200000
    m33s_nvm_C_S : ORIGIN = 0x18100000, LENGTH = 0x00200000
    m33s_nvm_S : ORIGIN = 0x70100000, LENGTH = 0x00200000
    m33s_trailer : ORIGIN = 0x60300000, LENGTH = 0x00040000
    m33s_trailer_C : ORIGIN = 0x08300000, LENGTH = 0x00040000
    m33s_trailer_C_S : ORIGIN = 0x18300000, LENGTH = 0x00040000
    m33s_trailer_S : ORIGIN = 0x70300000, LENGTH = 0x00040000
    m33_nvm : ORIGIN = 0x60340000, LENGTH = 0x00200000
    m33_nvm_C : ORIGIN = 0x08340000, LENGTH = 0x00200000
    m33_nvm_C_S : ORIGIN = 0x18340000, LENGTH = 0x00200000
    m33_nvm_S : ORIGIN = 0x70340000, LENGTH = 0x00200000
    m33_trailer : ORIGIN = 0x60540000, LENGTH = 0x00040000
    m33_trailer_C : ORIGIN = 0x08540000, LENGTH = 0x00040000
    m33_trailer_C_S : ORIGIN = 0x18540000, LENGTH = 0x00040000
    m33_trailer_S : ORIGIN = 0x70540000, LENGTH = 0x00040000
    m55_nvm : ORIGIN = 0x60580000, LENGTH = 0x00A00000
    m55_nvm_C : ORIGIN = 0x08580000, LENGTH = 0x00A00000
    m55_nvm_C_S : ORIGIN = 0x18580000, LENGTH = 0x00A00000
    m55_nvm_S : ORIGIN = 0x70580000, LENGTH = 0x00A00000
    m55_trailer : ORIGIN = 0x60F80000, LENGTH = 0x00040000
    m55_trailer_C : ORIGIN = 0x08F80000, LENGTH = 0x00040000
    m55_trailer_C_S : ORIGIN = 0x18F80000, LENGTH = 0x00040000
    m55_trailer_S : ORIGIN = 0x70F80000, LENGTH = 0x00040000
    m33_hyerram : ORIGIN = 0x64000000, LENGTH = 0x00200000
    m33_hyerram_C : ORIGIN = 0x0C000000, LENGTH = 0x00200000
    m33_hyerram_C_S : ORIGIN = 0x1C000000, LENGTH = 0x00200000
    m33_hyerram_S : ORIGIN = 0x74000000, LENGTH = 0x00200000
    m55_hyperram : ORIGIN = 0x64200000, LENGTH = 0x00200000
    m55_hyperram_C : ORIGIN = 0x0C200000, LENGTH = 0x00200000
    m55_hyperram_C_S : ORIGIN = 0x1C200000, LENGTH = 0x00200000
    m55_hyperram_S : ORIGIN = 0x74200000, LENGTH = 0x00200000
    m33_m55_shared_hyperram : ORIGIN = 0x64400000, LENGTH = 0x00C00000
    m33_m55_shared_hyperram_C : ORIGIN = 0x0C400000, LENGTH = 0x00C00000
    m33_m55_shared_hyperram_C_S : ORIGIN = 0x1C400000, LENGTH = 0x00C00000
    m33_m55_shared_hyperram_S : ORIGIN = 0x74400000, LENGTH = 0x00C00000
    m55_code_secondary : ORIGIN = 0x26000000, LENGTH = 0x00060000
    m55_code_secondary_C : ORIGIN = 0x06000000, LENGTH = 0x00060000
    m55_code_secondary_C_S : ORIGIN = 0x16000000, LENGTH = 0x00060000
    m55_code_secondary_S : ORIGIN = 0x36000000, LENGTH = 0x00060000
    m55_data_secondary : ORIGIN = 0x26060000, LENGTH = 0x00160000
    m55_data_secondary_C : ORIGIN = 0x06060000, LENGTH = 0x00160000
    m55_data_secondary_C_S : ORIGIN = 0x16060000, LENGTH = 0x00160000
    m55_data_secondary_S : ORIGIN = 0x36060000, LENGTH = 0x00160000
    m33_m55_shared : ORIGIN = 0x261C0000, LENGTH = 0x00040000
    m33_m55_shared_C : ORIGIN = 0x061C0000, LENGTH = 0x00040000
    m33_m55_shared_C_S : ORIGIN = 0x161C0000, LENGTH = 0x00040000
    m33_m55_shared_S : ORIGIN = 0x361C0000, LENGTH = 0x00040000
    gfx_mem : ORIGIN = 0x26200000, LENGTH = 0x00300000
    gfx_mem_C : ORIGIN = 0x06200000, LENGTH = 0x00300000
    gfx_mem_C_S : ORIGIN = 0x16200000, LENGTH = 0x00300000
    gfx_mem_S : ORIGIN = 0x36200000, LENGTH = 0x00300000
    m33s_shared : ORIGIN = 0x24001000, LENGTH = 0x00001000
    m33s_shared_C : ORIGIN = 0x04001000, LENGTH = 0x00001000
    m33s_shared_C_S : ORIGIN = 0x14001000, LENGTH = 0x00001000
    m33s_shared_S : ORIGIN = 0x34001000, LENGTH = 0x00001000
    m33s_code : ORIGIN = 0x24002000, LENGTH = 0x00035000
    m33s_code_C : ORIGIN = 0x04002000, LENGTH = 0x00035000
    m33s_code_C_S : ORIGIN = 0x14002000, LENGTH = 0x00035000
    m33s_code_S : ORIGIN = 0x34002000, LENGTH = 0x00035000
    m33s_data : ORIGIN = 0x24037000, LENGTH = 0x00021000
    m33s_data_C : ORIGIN = 0x04037000, LENGTH = 0x00021000
    m33s_data_C_S : ORIGIN = 0x14037000, LENGTH = 0x00021000
    m33s_data_S : ORIGIN = 0x34037000, LENGTH = 0x00021000
    m33_code : ORIGIN = 0x24058000, LENGTH = 0x00065000
    m33_code_C : ORIGIN = 0x04058000, LENGTH = 0x00065000
    m33_code_C_S : ORIGIN = 0x14058000, LENGTH = 0x00065000
    m33_code_S : ORIGIN = 0x34058000, LENGTH = 0x00065000
    m33_data : ORIGIN = 0x240BD000, LENGTH = 0x00040000
    m33_data_C : ORIGIN = 0x040BD000, LENGTH = 0x00040000
    m33_data_C_S : ORIGIN = 0x140BD000, LENGTH = 0x00040000
    m33_data_S : ORIGIN = 0x340BD000, LENGTH = 0x00040000
    m33s_allocatable_shared : ORIGIN = 0x240FD000, LENGTH = 0x00001000
    m33s_allocatable_shared_C : ORIGIN = 0x040FD000, LENGTH = 0x00001000
    m33s_allocatable_shared_C_S : ORIGIN = 0x140FD000, LENGTH = 0x00001000
    m33s_allocatable_shared_S : ORIGIN = 0x340FD000, LENGTH = 0x00001000
    m33_allocatable_shared : ORIGIN = 0x240FE000, LENGTH = 0x00001000
    m33_allocatable_shared_C : ORIGIN = 0x040FE000, LENGTH = 0x00001000
    m33_allocatable_shared_C_S : ORIGIN = 0x140FE000, LENGTH = 0x00001000
    m33_allocatable_shared_S : ORIGIN = 0x340FE000, LENGTH = 0x00001000
    m55_allocatable_shared : ORIGIN = 0x240FF000, LENGTH = 0x00001000
    m55_allocatable_shared_C : ORIGIN = 0x040FF000, LENGTH = 0x00001000
    m55_allocatable_shared_C_S : ORIGIN = 0x140FF000, LENGTH = 0x00001000
    m55_allocatable_shared_S : ORIGIN = 0x340FF000, LENGTH = 0x00001000
}

REGION_ALIAS("m55_data_sel", m55_data)
REGION_ALIAS("m55_data_sel_S", m55_data_S)
REGION_ALIAS("m55_code_sel", m55_code)
REGION_ALIAS("m55_code_sel_S", m55_code_S)
REGION_ALIAS("user_programmable_sel", user_programmable_C)
REGION_ALIAS("user_programmable_sel_S", user_programmable_C_S)
REGION_ALIAS("user_nvm_sel", user_nvm_C)
REGION_ALIAS("user_nvm_sel_S", user_nvm_C_S)
REGION_ALIAS("m33s_nvm_sel", m33s_nvm_C)
REGION_ALIAS("m33s_nvm_sel_S", m33s_nvm_C_S)
REGION_ALIAS("m33s_trailer_sel", m33s_trailer_C)
REGION_ALIAS("m33s_trailer_sel_S", m33s_trailer_C_S)
REGION_ALIAS("m33_nvm_sel", m33_nvm_C)
REGION_ALIAS("m33_nvm_sel_S", m33_nvm_C_S)
REGION_ALIAS("m33_trailer_sel", m33_trailer_C)
REGION_ALIAS("m33_trailer_sel_S", m33_trailer_C_S)
REGION_ALIAS("m55_nvm_sel", m55_nvm_C)
REGION_ALIAS("m55_nvm_sel_S", m55_nvm_C_S)
REGION_ALIAS("m55_trailer_sel", m55_trailer_C)
REGION_ALIAS("m55_trailer_sel_S", m55_trailer_C_S)
REGION_ALIAS("m33_hyerram_sel", m33_hyerram_C)
REGION_ALIAS("m33_hyerram_sel_S", m33_hyerram_C_S)
REGION_ALIAS("m55_hyperram_sel", m55_hyperram_C)
REGION_ALIAS("m55_hyperram_sel_S", m55_hyperram_C_S)
REGION_ALIAS("m33_m55_shared_hyperram_sel", m33_m55_shared_hyperram_C)
REGION_ALIAS("m33_m55_shared_hyperram_sel_S", m33_m55_shared_hyperram_C_S)
REGION_ALIAS("m55_code_secondary_sel", m55_code_secondary_C)
REGION_ALIAS("m55_code_secondary_sel_S", m55_code_secondary_C_S)
REGION_ALIAS("m55_data_secondary_sel", m55_data_secondary_C)
REGION_ALIAS("m55_data_secondary_sel_S", m55_data_secondary_C_S)
REGION_ALIAS("m33_m55_shared_sel", m33_m55_shared_C)
REGION_ALIAS("m33_m55_shared_sel_S", m33_m55_shared_C_S)
REGION_ALIAS("gfx_mem_sel", gfx_mem_C)
REGION_ALIAS("gfx_mem_sel_S", gfx_mem_C_S)
REGION_ALIAS("m33s_shared_sel", m33s_shared_C)
REGION_ALIAS("m33s_shared_sel_S", m33s_shared_C_S)
REGION_ALIAS("m33s_code_sel", m33s_code_C)
REGION_ALIAS("m33s_code_sel_S", m33s_code_C_S)
REGION_ALIAS("m33s_data_sel", m33s_data_C)
REGION_ALIAS("m33s_data_sel_S", m33s_data_C_S)
REGION_ALIAS("m33_code_sel", m33_code_C)
REGION_ALIAS("m33_code_sel_S", m33_code_C_S)
REGION_ALIAS("m33_data_sel", m33_data_C)
REGION_ALIAS("m33_data_sel_S", m33_data_C_S)
REGION_ALIAS("m33s_allocatable_shared_sel", m33s_allocatable_shared_C)
REGION_ALIAS("m33s_allocatable_shared_sel_S", m33s_allocatable_shared_C_S)
REGION_ALIAS("m33_allocatable_shared_sel", m33_allocatable_shared_C)
REGION_ALIAS("m33_allocatable_shared_sel_S", m33_allocatable_shared_C_S)
REGION_ALIAS("m55_allocatable_shared_sel", m55_allocatable_shared_C)
REGION_ALIAS("m55_allocatable_shared_sel_S", m55_allocatable_shared_C_S)


/* Linker script to place sections and symbol values. Should be used together
 * with other linker script that defines memory regions FLASH and RAM.
 * It references following symbols, which must be defined in code:
 *   Reset_Handler : Entry of reset handler
 *
 * It defines following symbols, which code can use without definition:
 *   __exidx_start
 *   __exidx_end
 *   __copy_table_start__
 *   __copy_table_end__
 *   __zero_table_start__
 *   __zero_table_end__
 *   __data_start__
 *   __preinit_array_start
 *   __preinit_array_end
 *   __init_array_start
 *   __init_array_end
 *   __fini_array_start
 *   __fini_array_end
 *   __data_end__
 *   __bss_start__
 *   __bss_end__
 *   __end__
 *   end
 *   __HeapLimit
 *   __StackLimit
 *   __StackTop
 *   __stack
 */

/* Device definitions */
VECTORS_ALIGNMENT = 0x400;

/* Compute the difference between S-AHB address and C-AHB address for
*  section m33s_code_S. This value is used to correctly
*  copy code in the copy table.
*  This is needed because the code needs to be accessed from the C-AHB
*  address (faster, better performance) but since this is a read-only
*  address to perform the copy we need to specify the S-AHB address which
*  allows for writes as well.
*/
m33s_code_sel_S_Offset = ORIGIN(m33s_code_S) - ORIGIN(m33s_code_sel_S);

/* The size of the MCU boot header area at the start of main code region */
MCUBOOT_HEADER_SIZE = 0x400;

/* Define the sections */
SECTIONS
{
    /* This section reserves a space for MCUBoot header */
    .mcu_boot_header(READONLY) : ALIGN(MCUBOOT_HEADER_SIZE)
    {
        . += MCUBOOT_HEADER_SIZE;
    } > m33s_nvm_sel_S

    /* This section is dedicated to the vector table */
    .vector_table() : ALIGN(VECTORS_ALIGNMENT)
    {
        /* Keep the vector table */
        KEEP(*(.vectors))
    } > m33s_nvm_sel_S

    /* A section for the veneer code of Secure APIs */
    .gnu.sgstubs : ALIGN(32)
    {
        . = ALIGN(32);
        __nsc_start = .;
        KEEP(*(.gnu.sgstubs*))
        . = ALIGN(32);
    } > m33s_nvm_sel_S

    /* Empty section to generate the end address of the NSC section correctly
       see https://answers.launchpad.net/gcc-arm-embedded/+question/697333  */
    empty_section : ALIGN(32)
    {
	__nsc_end = .;
    } > m33s_nvm_sel_S

    PROVIDE(__nsc_region_start = __nsc_start);
    PROVIDE(__nsc_region_size = __nsc_end - __nsc_start);

    /* This section is intended to hold the main secure (S) application code for the Cortex-M33 */
    /* Performance-sensitive or critical functions that need to be executed in sram are manually excluded */
    .app_code_main : ALIGN(VECTORS_ALIGNMENT)
    {
        /* Keep initializers */
        KEEP(*(.init))
        /* Keep finalizers */
        KEEP(*(.fini))
        /* Static constructors */
        *crtbegin.*(.ctors)
        *crtbegin?.*(.ctors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .ctors)
        *(SORT(.ctors.*))
        *(.ctors)
        /* Static destructors and atexit() */
        *crtbegin.*(.dtors)
        *crtbegin?.*(.dtors)
        *(EXCLUDE_FILE(*crtend?.* *crtend.*) .dtors)
        *(SORT(.dtors.*))
        *(.dtors)

        . = ALIGN(4);

        /* Array of pointers to preinint functions */
        PROVIDE_HIDDEN(__preinit_array_start = .);

        KEEP(*(.preinit_array))

        PROVIDE_HIDDEN(__preinit_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to init functions */
        PROVIDE_HIDDEN(__init_array_start = .);

        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array))

        PROVIDE_HIDDEN(__init_array_end = .);

        . = ALIGN(4);

        /* Array of pointers to finalizer functions */

        PROVIDE_HIDDEN(__fini_array_start = .);

        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array))

        PROVIDE_HIDDEN(__fini_array_end = .);

        /* Read only code (constants) */
        *(.rodata .rodata.* .constdata .constdata.* .conststring .conststring.*)
        /* Exclude certain files from this section as they will be placed in RAM */
        *(EXCLUDE_FILE(*cy_syslib.* *cy_syslib_ext.* *cy_smif.* *cy_smif_memnum.* *cy_smif_memslot.* *cy_smif_sfdp.* *cy_smif_hb_flash.* *mtb_hal_memoryspi.* *mtb_serial_memory.*) .text*)
    } > m33s_nvm_sel_S

    /* Exception tables for ARM architecture */
    .ARM.extab (READONLY): ALIGN(4)
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)
    } > m33s_nvm_sel_S


    /* Exception index tables for ARM architecture */
    .ARM.exidx (READONLY): ALIGN(4)
    {
        __exidx_start = .;

        *(.ARM.exidx* .gnu.linkonce.armexidx.*)

        __exidx_end = .;
    } > m33s_nvm_sel_S


    /* Define copying of data from flash memory to RAM during the startup */
    .copy.table (READONLY): ALIGN(4)
    {
        __copy_table_start__ = .;

        /* Initialized data in SRAM */
        LONG (LOADADDR(.data))                      /* From load address in ext flash */
        LONG (ADDR(.data))                          /* To run address in RAM */
        LONG (SIZEOF(.data)/4)                      /* Size in words */

        /* Performance-sensitive or critical functions that need to be executed in SRAM */
        LONG(LOADADDR(.app_code_ram))                       /* From load address in ext flash */
        LONG(ADDR(.app_code_ram) + m33s_code_sel_S_Offset)  /* To run address in RAM - using S-AHB for copying */
        LONG(SIZEOF(.app_code_ram)/4)                       /* Size in words */

        __copy_table_end__ = .;
    } > m33s_nvm_sel_S

    /* Define zeroing of the uninitialized data section */
    .zero.table (READONLY): ALIGN(4)
    {
        __zero_table_start__ = .;

        LONG(__bss_start__)                       /* Start of the zero-initialized data section */
        LONG((__bss_end__ - __bss_start__)/4)     /* Size of the zero-initialized data section in words */

        __zero_table_end__ = .;
    } > m33s_nvm_sel_S

    /* A section for the vector table */
    .ram_vectors (NOLOAD) : ALIGN(VECTORS_ALIGNMENT)
    {
        __ram_vectors_start__ = .;

        KEEP(*(.ram_vectors))

        __ram_vectors_end__ = .;
    } > m33s_data_S

    /* A section for initialized data memory */
    .data : ALIGN(4)
    {
        __data_start__ = .;

        *(.data*)
        KEEP(*(.jcr*))

        . = ALIGN(4);

        __data_end__ = .;
    } > m33s_data_S AT > m33s_nvm_sel_S

    /* A section for non-initialized data memory */
    .bss(NOLOAD) : ALIGN(4)
    {
        __bss_start__ = .;

        *(.bss*)
        *(COMMON)

        . = ALIGN(4);

        __bss_end__ = .;
    } > m33s_data_S

    /* A section for variables that should not be initialized during the device startup */
    .noinit (NOLOAD) :
    {
        KEEP(*(.noinit))
    } > m33s_data_S

    /* A section for the heap memory */
    .heap(NOLOAD) : ALIGN(8)
    {
        __HeapBase = .;
        __end__ = .;
        end = __end__;

        KEEP(*(.heap*))

        . = ALIGN(8);
        . = ORIGIN(m33s_data_S) + LENGTH(m33s_data_S) - __StackSize;
        __HeapLimit = .;
    } > m33s_data_S

    /* A section for performance-sensitive or critical functions that need to be executed in SRAM */
    .app_code_ram : ALIGN(4)
    {
        __cy_sram0_code_vma_start__ = .;

        KEEP(*(.cy_sram_code))
        KEEP(*(.cy_ramfunc))
        KEEP(*(.text.cy_os_common))
        *cy_syslib_ext.*(.text*)
        *cy_syslib.*(.text*)
        *cy_smif.*(.text*)
        *cy_smif_memnum.*(.text*)
        *cy_smif_memslot.*(.text*)
        *cy_smif_sfdp.*(.text*)
        *cy_smif_hb_flash.*(.text*)
        *mtb_hal_memoryspi.*(.text*)
        *mtb_serial_memory.*(.text*)

        . = ALIGN(4);

        __cy_sram0_code_vma_end__ = .;
    } > m33s_code_sel_S AT > m33s_nvm_sel_S

    /* A section for secure shared RAM memory */
    .cy_sharedmem_sec (NOLOAD):
    {
        __sec_ram_start__ = .;

        KEEP(*(.cy_sharedmem_sec))

        __sec_ram_end__ = .;
    } > m33s_shared_S

    /* A section for shared RAM memory where only the Cortex-M33 Secure can allocate data but all cores can access */
    .cy_sharedmem(NOLOAD):
    {
        __public_ram_start__ = .;

        KEEP(*(.cy_sharedmem))

        __public_ram_end__ = .;
    } > m33s_allocatable_shared_S

    __StackTop = ORIGIN(m33s_data_S) + LENGTH(m33s_data_S);
    __StackLimit = __StackTop - __StackSize;
    PROVIDE(__stack = __StackTop);

    /* Check if data + stack exceeds RAM limit still allows for Heap to be placed */
    ASSERT(
        __HeapLimit  >= __HeapBase,
        "Error: RAM region overflowed with stack. Ensure that the stack size is within the available RAM."
    )

    /* Reserve a trail space for the signature for the bootloader - do not place any code here */
    .cy_trailer(NOLOAD) :
    {
    } > m33s_trailer_sel_S
}
